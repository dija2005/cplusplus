#include <filesystem>
#include <fstream>
#include <iostream>
#include <regex>
#include <string>
#include <vector>
#include <map>
#include <algorithm>

namespace fs = std::filesystem;

// Checkt grob, ob eine Datei wahrscheinlich binär ist
bool is_binary(const fs::path& p) {
    std::ifstream f(p, std::ios::binary);
    if (!f) return true;

    char buf[256];
    f.read(buf, sizeof(buf));

    for (int i = 0; i < f.gcount(); i++)
        if (buf[i] == '\0')
            return true;

    return false;
}

int main(int argc, char** argv) {
    bool ignore_case = false;
    bool no_heading = false;
    int before = 0;
    int after = 0;

    std::string pattern;
    std::string root = ".";

    // Kommandozeilen-Argumente einsammeln
    for (int i = 1; i < argc; i++) {
        std::string a = argv[i];

        if (a == "-i") ignore_case = true;
        else if (a == "--no-heading") no_heading = true;
        else if (a == "-A" && i + 1 < argc) after = std::stoi(argv[++i]);
        else if (a == "-B" && i + 1 < argc) before = std::stoi(argv[++i]);
        else if (a == "-C" && i + 1 < argc) {
            before = after = std::stoi(argv[++i]);
        }
        else if (pattern.empty()) pattern = a;
        else root = a;
    }

    // Kein Suchmuster → nichts zu tun
    if (pattern.empty()) return 0;

    auto flags = std::regex::ECMAScript;
    if (ignore_case) flags |= std::regex::icase;
    std::regex rx(pattern, flags);

    // Alle Dateien rekursiv einsammeln und sortiert ablegen
    std::map<std::string, std::vector<std::string>> files;

    for (auto& e : fs::recursive_directory_iterator(root)) {
        if (!e.is_regular_file()) continue;
        if (is_binary(e.path())) continue;

        std::ifstream f(e.path());
        if (!f) continue;

        std::vector<std::string> lines;
        std::string line;
        while (std::getline(f, line))
            lines.push_back(line);

        files[e.path().string()] = lines;
    }

    bool first_output = true;

    for (auto& [file, lines] : files) {
        std::vector<int> hits;

        // Alle Zeilen merken, die auf das Regex matchen
        for (int i = 0; i < (int)lines.size(); i++)
            if (std::regex_search(lines[i], rx))
                hits.push_back(i);

        if (hits.empty()) continue;

        // Kontext-Blöcke um Treffer herum bauen
        std::vector<std::pair<int,int>> blocks;
        for (int h : hits) {
            int l = std::max(0, h - before);
            int r = std::min((int)lines.size() - 1, h + after);
            blocks.push_back({l, r});
        }

        // Überlappende Kontextbereiche zusammenziehen
        std::sort(blocks.begin(), blocks.end());
        std::vector<std::pair<int,int>> merged;

        for (auto& b : blocks) {
            if (merged.empty() || b.first > merged.back().second + 1)
                merged.push_back(b);
            else
                merged.back().second = std::max(merged.back().second, b.second);
        }

        // Trenner zwischen Dateien, wenn kein Dateikopf ausgegeben wird
        if (no_heading && !first_output)
            std::cout << "--\n";

        first_output = false;

        // Dateiname ausgeben (außer bei --no-heading)
        if (!no_heading)
            std::cout << file << "\n";

        for (size_t bi = 0; bi < merged.size(); bi++) {
            if (bi > 0)
                std::cout << "--\n";

            for (int i = merged[bi].first; i <= merged[bi].second; i++) {
                bool is_hit = std::find(hits.begin(), hits.end(), i) != hits.end();
                char sep = is_hit ? ':' : '-';

                if (no_heading)
                    std::cout << file << sep << (i + 1) << sep << lines[i] << "\n";
                else
                    std::cout << (i + 1) << sep << lines[i] << "\n";
            }
        }
    }

    return 0;
}